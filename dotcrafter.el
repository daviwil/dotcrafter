(defcustom dotcrafter-dotfiles-folder "~/.dotfiles"
  "The folder where dotfiles and org-mode configuration files are stored."
  :type 'string
  :group 'dotfiles)

(defcustom dotcrafter-output-directory "~"
  "The directory where dotcrafter.el will write out your dotfiles.
This is typically set to '~' but can be changed for testing
purposes."
  :type 'string
  :group 'dotfiles)

(defcustom dotcrafter-org-files '()
  "The list of org-mode files under the `dotcrafter-dotfiles-folder'
which contain configuration files that should be tangled"
  :type '(list string)
  :group 'dotfiles)

(defcustom dotcrafter-extra-files-directory ".files"
  "The directory path inside of `dotcrafter-dotfiles-folder' where
\"extra\" configuration files are stored."
  :type 'string
  :group 'dotfiles)

(defcustom dotcrafter-ensure-output-directories '(".config" ".local/share")
  "List of directories in the output folder that should be created
before linking \"extra\" configuration files."
  :type  '(list string)
  :group 'dotfiles)

(defvar dotcrafter-gitignore-marker "\n# -- Generated by dotcrafter.el! --\n\n"
  "The marker string to be placed in the .gitignore file of the
dotfiles repo to indicate where the auto-generated list of ignored
files begins.")

(defun dotcrafter--scan-for-output-files (org-file)
  (let ((output-files '())
        (current-match t))
    ;; Get a buffer for the file, either one that is
    ;; already open or open a new one
    (with-current-buffer (or (get-file-buffer org-file)
                             (find-file-noselect org-file))
      ;; Save the current buffer position
      (save-excursion
        ;; Go back to the beginning of the buffer
        (goto-char (point-min))

        ;; Loop until no more matches are found
        (while current-match
          ;; Search for blocks with a :tangle property
          (setq current-match (search-forward ":tangle " nil t))
          (when current-match
            (let ((output-file (thing-at-point 'filename t)))
              ;; If a file path was found, add it to the list
              (unless (or (not output-file)
                          (string-equal output-file "no"))
                (setq output-files (cons output-file
                                         output-files))))))))
    output-files))

(defun dotcrafter--update-gitignore ()
  (let ((output-files '()))
    ;; Gather the list of output files from all Org files
    (dolist (org-file dotcrafter-org-files)
      (setq output-files
            (append output-files
                    (dotcrafter--scan-for-output-files
                     (expand-file-name org-file dotcrafter-dotfiles-folder)))))

    ;; Now that we have the output files, update the .gitignore file
    (let ((gitignore-file (expand-file-name ".gitignore"
                                            dotcrafter-dotfiles-folder)))
      ;; Find the .gitignore buffer and prepare for editing
      (with-current-buffer (or (get-file-buffer gitignore-file)
                               (find-file-noselect gitignore-file))
        (save-excursion
          ;; Find or insert the dotcrafter-gitignore-marker
          (beginning-of-buffer)
          (or (progn
                (search-forward dotcrafter-gitignore-marker nil t))
              (progn
                (end-of-buffer)
                (insert "\n" dotcrafter-gitignore-marker)))

          ;; Delete the rest of the buffer after the marker
          (delete-region (point) (point-max))

          ;; Insert a line for each output file
          (dolist (output-file output-files)
            (insert output-file "\n"))

          ;; Make sure the buffer is saved
          (save-buffer))))))

(defun dotcrafter-tangle-org-file (&optional org-file)
  "Tangles a single .org file relative to the path in
dotfiles-folder.  If no file is specified, tangle the current
file if it is an org-mode buffer inside of dotfiles-folder."
  (interactive)
  ;; Suppress prompts and messages
  (let ((org-confirm-babel-evaluate nil)
        (message-log-max nil)
        (inhibit-message t))
    (org-babel-tangle-file (expand-file-name org-file dotcrafter-dotfiles-folder))))

(defun dotcrafter-tangle-org-files ()
  "Tangles all of the .org files in the paths specified by the variable dotfiles-folder"
  (interactive)
  (dolist (org-file dotcrafter-org-files)
    (dotcrafter-tangle-org-file org-file))
  (message "Dotfiles are up to date!"))

(defun dotcrafter--link-extra-file (extra-file)
  ;; Get the "path parts", basically the name of each directory and file in the
  ;; path of extra-file
  (let* ((path-parts
          (split-string (file-relative-name (expand-file-name extra-file)
                                            (expand-file-name dotcrafter-extra-files-directory
                                                              dotcrafter-dotfiles-folder))
                        "/" t))
         (current-path nil))
    ;; Check each "part" of the path to find the right place to create the symlink.
    ;; Whenever path-parts is nil, stop looping!
    (while path-parts
      ;; Create the current path using the first part and remove it from the
      ;; front of the list for future recursive calls
      (setq current-path (if current-path
                             (concat current-path "/" (car path-parts))
                           (car path-parts)))
      (setq path-parts (cdr path-parts))

      ;; Figure out whether the current source path can be linked to the target path
      (let ((source-path (expand-file-name (concat dotcrafter-extra-files-directory "/" current-path)
                                           dotcrafter-dotfiles-folder))
            (target-path (expand-file-name current-path dotcrafter-output-directory)))
        ;; If the file or directory exists, is it a symbolic link?
        (if (file-symlink-p target-path)
            ;; If the symbolic link exists, does it point to the source-path?
            (if (not (string-equal source-path (file-truename target-path)))
                (error "Path already exists with different symlink! %s" target-path)
              ;; Clear path-parts to stop looping
              (setq path-parts '()))
          ;; If the target path is an existing directory, we need to keep
          ;; looping, otherwise we can create a symlink here!
          ;; Otherwise, the file is probably a directory so recurse
          (when (not (file-directory-p target-path))
            ;; Create a symbolic link to the source-path and
            ;; clear the path-parts so that we stop looping
            (make-symbolic-link source-path target-path)
            (setq path-parts '())))))))

(defun dotcrafter-link-extra-files ()
  (interactive)
  (let ((extra-files
         (directory-files-recursively
          (expand-file-name dotcrafter-extra-files-directory
                            dotcrafter-dotfiles-folder)
          "")))
    ;; Ensure that the expected output directories are already
    ;; created so that links will be created inside
    (dolist (dir dotcrafter-ensure-output-directories)
      (make-directory (expand-file-name dir dotcrafter-output-directory) t))

    ;; Link all of the source config files to the output path
    (dolist (file extra-files)
      (dotcrafter--link-extra-file file))))

(provide 'dotcrafter)
